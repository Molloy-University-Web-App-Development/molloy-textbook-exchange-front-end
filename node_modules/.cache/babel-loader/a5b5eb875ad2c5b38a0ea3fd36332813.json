{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst Bignumber = require('bignumber.js').BigNumber;\n\nconst constants = require('./constants');\n\nconst SHIFT32 = constants.SHIFT32;\nconst SHIFT16 = constants.SHIFT16;\nconst MAX_SAFE_HIGH = 0x1fffff;\n\nexports.parseHalf = function parseHalf(buf) {\n  var exp, mant, sign;\n  sign = buf[0] & 0x80 ? -1 : 1;\n  exp = (buf[0] & 0x7C) >> 2;\n  mant = (buf[0] & 0x03) << 8 | buf[1];\n\n  if (!exp) {\n    return sign * 5.9604644775390625e-8 * mant;\n  } else if (exp === 0x1f) {\n    return sign * (mant ? 0 / 0 : 2e308);\n  } else {\n    return sign * Math.pow(2, exp - 25) * (1024 + mant);\n  }\n};\n\nfunction toHex(n) {\n  if (n < 16) {\n    return '0' + n.toString(16);\n  }\n\n  return n.toString(16);\n}\n\nexports.arrayBufferToBignumber = function (buf) {\n  const len = buf.byteLength;\n  let res = '';\n\n  for (let i = 0; i < len; i++) {\n    res += toHex(buf[i]);\n  }\n\n  return new Bignumber(res, 16);\n}; // convert an Object into a Map\n\n\nexports.buildMap = obj => {\n  const res = new Map();\n  const keys = Object.keys(obj);\n  const length = keys.length;\n\n  for (let i = 0; i < length; i++) {\n    res.set(keys[i], obj[keys[i]]);\n  }\n\n  return res;\n};\n\nexports.buildInt32 = (f, g) => {\n  return f * SHIFT16 + g;\n};\n\nexports.buildInt64 = (f1, f2, g1, g2) => {\n  const f = exports.buildInt32(f1, f2);\n  const g = exports.buildInt32(g1, g2);\n\n  if (f > MAX_SAFE_HIGH) {\n    return new Bignumber(f).times(SHIFT32).plus(g);\n  } else {\n    return f * SHIFT32 + g;\n  }\n};\n\nexports.writeHalf = function writeHalf(buf, half) {\n  // assume 0, -0, NaN, Infinity, and -Infinity have already been caught\n  // HACK: everyone settle in.  This isn't going to be pretty.\n  // Translate cn-cbor's C code (from Carsten Borman):\n  // uint32_t be32;\n  // uint16_t be16, u16;\n  // union {\n  //   float f;\n  //   uint32_t u;\n  // } u32;\n  // u32.f = float_val;\n  const u32 = Buffer.allocUnsafe(4);\n  u32.writeFloatBE(half, 0);\n  const u = u32.readUInt32BE(0); // if ((u32.u & 0x1FFF) == 0) { /* worth trying half */\n  // hildjj: If the lower 13 bits are 0, we won't lose anything in the conversion\n\n  if ((u & 0x1FFF) !== 0) {\n    return false;\n  } //   int s16 = (u32.u >> 16) & 0x8000;\n  //   int exp = (u32.u >> 23) & 0xff;\n  //   int mant = u32.u & 0x7fffff;\n\n\n  var s16 = u >> 16 & 0x8000; // top bit is sign\n\n  const exp = u >> 23 & 0xff; // then 5 bits of exponent\n\n  const mant = u & 0x7fffff; //   if (exp == 0 && mant == 0)\n  //     ;              /* 0.0, -0.0 */\n  // hildjj: zeros already handled.  Assert if you don't believe me.\n  //   else if (exp >= 113 && exp <= 142) /* normalized */\n  //     s16 += ((exp - 112) << 10) + (mant >> 13);\n\n  if (exp >= 113 && exp <= 142) {\n    s16 += (exp - 112 << 10) + (mant >> 13); //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */\n    //     if (mant & ((1 << (126 - exp)) - 1))\n    //       goto float32;         /* loss of precision */\n    //     s16 += ((mant + 0x800000) >> (126 - exp));\n  } else if (exp >= 103 && exp < 113) {\n    if (mant & (1 << 126 - exp) - 1) {\n      return false;\n    }\n\n    s16 += mant + 0x800000 >> 126 - exp; //   } else if (exp == 255 && mant == 0) { /* Inf */\n    //     s16 += 0x7c00;\n    // hildjj: Infinity already handled\n    //   } else\n    //     goto float32;           /* loss of range */\n  } else {\n    return false;\n  } //   ensure_writable(3);\n  //   u16 = s16;\n  //   be16 = hton16p((const uint8_t*)&u16);\n\n\n  buf.writeUInt16BE(s16, 0);\n  return true;\n};\n\nexports.keySorter = function (a, b) {\n  var lenA = a[0].byteLength;\n  var lenB = b[0].byteLength;\n\n  if (lenA > lenB) {\n    return 1;\n  }\n\n  if (lenB > lenA) {\n    return -1;\n  }\n\n  return a[0].compare(b[0]);\n}; // Adapted from http://www.2ality.com/2012/03/signedzero.html\n\n\nexports.isNegativeZero = x => {\n  return x === 0 && 1 / x < 0;\n};\n\nexports.nextPowerOf2 = n => {\n  let count = 0; // First n in the below condition is for\n  // the case where n is 0\n\n  if (n && !(n & n - 1)) {\n    return n;\n  }\n\n  while (n !== 0) {\n    n >>= 1;\n    count += 1;\n  }\n\n  return 1 << count;\n};","map":{"version":3,"names":["Buffer","require","Bignumber","BigNumber","constants","SHIFT32","SHIFT16","MAX_SAFE_HIGH","exports","parseHalf","buf","exp","mant","sign","Math","pow","toHex","n","toString","arrayBufferToBignumber","len","byteLength","res","i","buildMap","obj","Map","keys","Object","length","set","buildInt32","f","g","buildInt64","f1","f2","g1","g2","times","plus","writeHalf","half","u32","allocUnsafe","writeFloatBE","u","readUInt32BE","s16","writeUInt16BE","keySorter","a","b","lenA","lenB","compare","isNegativeZero","x","nextPowerOf2","count"],"sources":["/Users/roberttineo/Documents/GitHub/molloy-textbook-exchange-front-end/node_modules/borc/src/utils.js"],"sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst Bignumber = require('bignumber.js').BigNumber\n\nconst constants = require('./constants')\nconst SHIFT32 = constants.SHIFT32\nconst SHIFT16 = constants.SHIFT16\nconst MAX_SAFE_HIGH = 0x1fffff\n\nexports.parseHalf = function parseHalf (buf) {\n  var exp, mant, sign\n  sign = buf[0] & 0x80 ? -1 : 1\n  exp = (buf[0] & 0x7C) >> 2\n  mant = ((buf[0] & 0x03) << 8) | buf[1]\n  if (!exp) {\n    return sign * 5.9604644775390625e-8 * mant\n  } else if (exp === 0x1f) {\n    return sign * (mant ? 0 / 0 : 2e308)\n  } else {\n    return sign * Math.pow(2, exp - 25) * (1024 + mant)\n  }\n}\n\nfunction toHex (n) {\n  if (n < 16) {\n    return '0' + n.toString(16)\n  }\n\n  return n.toString(16)\n}\n\nexports.arrayBufferToBignumber = function (buf) {\n  const len = buf.byteLength\n  let res = ''\n  for (let i = 0; i < len; i++) {\n    res += toHex(buf[i])\n  }\n\n  return new Bignumber(res, 16)\n}\n\n// convert an Object into a Map\nexports.buildMap = (obj) => {\n  const res = new Map()\n  const keys = Object.keys(obj)\n  const length = keys.length\n  for (let i = 0; i < length; i++) {\n    res.set(keys[i], obj[keys[i]])\n  }\n  return res\n}\n\nexports.buildInt32 = (f, g) => {\n  return f * SHIFT16 + g\n}\n\nexports.buildInt64 = (f1, f2, g1, g2) => {\n  const f = exports.buildInt32(f1, f2)\n  const g = exports.buildInt32(g1, g2)\n\n  if (f > MAX_SAFE_HIGH) {\n    return new Bignumber(f).times(SHIFT32).plus(g)\n  } else {\n    return (f * SHIFT32) + g\n  }\n}\n\nexports.writeHalf = function writeHalf (buf, half) {\n  // assume 0, -0, NaN, Infinity, and -Infinity have already been caught\n\n  // HACK: everyone settle in.  This isn't going to be pretty.\n  // Translate cn-cbor's C code (from Carsten Borman):\n\n  // uint32_t be32;\n  // uint16_t be16, u16;\n  // union {\n  //   float f;\n  //   uint32_t u;\n  // } u32;\n  // u32.f = float_val;\n\n  const u32 = Buffer.allocUnsafe(4)\n  u32.writeFloatBE(half, 0)\n  const u = u32.readUInt32BE(0)\n\n  // if ((u32.u & 0x1FFF) == 0) { /* worth trying half */\n\n  // hildjj: If the lower 13 bits are 0, we won't lose anything in the conversion\n  if ((u & 0x1FFF) !== 0) {\n    return false\n  }\n\n  //   int s16 = (u32.u >> 16) & 0x8000;\n  //   int exp = (u32.u >> 23) & 0xff;\n  //   int mant = u32.u & 0x7fffff;\n\n  var s16 = (u >> 16) & 0x8000 // top bit is sign\n  const exp = (u >> 23) & 0xff // then 5 bits of exponent\n  const mant = u & 0x7fffff\n\n  //   if (exp == 0 && mant == 0)\n  //     ;              /* 0.0, -0.0 */\n\n  // hildjj: zeros already handled.  Assert if you don't believe me.\n\n  //   else if (exp >= 113 && exp <= 142) /* normalized */\n  //     s16 += ((exp - 112) << 10) + (mant >> 13);\n  if ((exp >= 113) && (exp <= 142)) {\n    s16 += ((exp - 112) << 10) + (mant >> 13)\n\n  //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */\n  //     if (mant & ((1 << (126 - exp)) - 1))\n  //       goto float32;         /* loss of precision */\n  //     s16 += ((mant + 0x800000) >> (126 - exp));\n  } else if ((exp >= 103) && (exp < 113)) {\n    if (mant & ((1 << (126 - exp)) - 1)) {\n      return false\n    }\n    s16 += ((mant + 0x800000) >> (126 - exp))\n\n    //   } else if (exp == 255 && mant == 0) { /* Inf */\n    //     s16 += 0x7c00;\n\n    // hildjj: Infinity already handled\n\n  //   } else\n  //     goto float32;           /* loss of range */\n  } else {\n    return false\n  }\n\n  //   ensure_writable(3);\n  //   u16 = s16;\n  //   be16 = hton16p((const uint8_t*)&u16);\n  buf.writeUInt16BE(s16, 0)\n  return true\n}\n\nexports.keySorter = function (a, b) {\n  var lenA = a[0].byteLength\n  var lenB = b[0].byteLength\n\n  if (lenA > lenB) {\n    return 1\n  }\n\n  if (lenB > lenA) {\n    return -1\n  }\n\n  return a[0].compare(b[0])\n}\n\n// Adapted from http://www.2ality.com/2012/03/signedzero.html\nexports.isNegativeZero = (x) => {\n  return x === 0 && (1 / x < 0)\n}\n\nexports.nextPowerOf2 = (n) => {\n  let count = 0\n  // First n in the below condition is for\n  // the case where n is 0\n  if (n && !(n & (n - 1))) {\n    return n\n  }\n\n  while (n !== 0) {\n    n >>= 1\n    count += 1\n  }\n\n  return 1 << count\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}