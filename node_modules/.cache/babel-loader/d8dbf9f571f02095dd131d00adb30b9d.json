{"ast":null,"code":"/*!\n * Copyright (c) 2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nimport * as cbor from 'borc';\nimport { TextDecoder, stringToUint8Array } from './util.js';\nexport class Hashlink {\n  /**\n   * Encodes a new Hashlink instance that can be used to encode or decode\n   * data at URLs.\n   *\n   * @returns {Hashlink} A Hashlink used to encode and decode cryptographic\n   *   hyperlinks.\n   */\n  constructor() {\n    this.registeredCodecs = {};\n  }\n  /**\n   * Encodes a hashlink. If only a `url` parameter is provided, the URL is\n   * fetched, transformed, and encoded into a hashlink. If a data parameter\n   * is provided, the hashlink is encoded from the data.\n   *\n   * @param {Object} options - The options for the encode operation.\n   * @param {Uint8Array} [options.data] - The data associated with the given\n   *   URL. If provided, this data is used to encode the cryptographic hash.\n   * @param {Array} options.codecs - One or more codecs that should be used\n   *   to encode the data.\n   * @param {Array} [options.urls] - One or more URLs that contain the data\n   *   referred to by the hashlink.\n   * @param {Object} [options.meta] - A set of key-value metadata that will be\n   *   encoded into the hashlink.\n   *\n   * @returns {Promise<string>} Resolves to a string that is a hashlink.\n   */\n\n\n  async encode(_ref) {\n    let {\n      data,\n      urls,\n      codecs,\n      meta = {}\n    } = _ref;\n\n    // ensure data or urls are provided\n    if (data === undefined && urls === undefined) {\n      throw new Error('Either `data` or `urls` must be provided.');\n    } // ensure codecs are provided\n\n\n    if (codecs === undefined) {\n      throw new Error('The hashlink creation `codecs` must be provided.');\n    }\n\n    if (urls !== undefined) {\n      // ensure urls are an array\n      if (!Array.isArray(urls)) {\n        urls = [urls];\n      } // ensure all URLs are strings\n\n\n      urls.forEach(url => {\n        if (typeof url !== 'string') {\n          throw new Error(`URL \"${url}\" must be a string.`);\n        }\n      }); // merge meta options with urls\n\n      meta = { ...meta,\n        url: urls\n      };\n    } // generate the encoded cryptographic hash\n\n\n    const outputData = await codecs.reduce(async (output, codec) => {\n      const encoder = this.registeredCodecs[codec];\n\n      if (encoder === undefined) {\n        throw new Error(`Unknown cryptographic hash encoder \"${encoder}\".`);\n      }\n\n      return encoder.encode(await output);\n    }, data); // generate the encoded metadata\n\n    const metadata = new Map();\n\n    if (meta.url) {\n      metadata.set(0x0f, meta.url);\n    }\n\n    if (meta['content-type']) {\n      metadata.set(0x0e, meta['content-type']);\n    }\n\n    if (meta.experimental) {\n      metadata.set(0x0d, meta.experimental);\n    }\n\n    if (meta.transform) {\n      metadata.set(0x0c, meta.transform);\n    } // build the hashlink\n\n\n    const textDecoder = new TextDecoder();\n    let hashlink = 'hl:' + textDecoder.decode(outputData); // append meta data if present\n\n    if (metadata.size > 0) {\n      const baseEncodingCodec = codecs[codecs.length - 1];\n      const cborData = new Uint8Array(cbor.encode(metadata));\n      const mbCborData = textDecoder.decode(this.registeredCodecs[baseEncodingCodec].encode(cborData));\n      hashlink += ':' + mbCborData;\n    }\n\n    return hashlink;\n  }\n  /**\n   * Decodes a hashlink resulting in an object with key-value pairs\n   * representing the values encoded in the hashlink.\n   *\n   * @param {Object} options - The options for the encode operation.\n   * @param {string} options.hashlink - The encoded hashlink value to decode.\n   *\n   * @returns {Object} Returns an object with the decoded hashlink values.\n   */\n\n\n  decode(_ref2) {\n    let {\n      hashlink\n    } = _ref2;\n    throw new Error('Not implemented.');\n  }\n  /**\n   * Verifies a hashlink resulting in a simple true or false value.\n   *\n   * @param {Object} options - The options for the encode operation.\n   * @param {string} options.hashlink - The encoded hashlink value to verify.\n   * @param {string} options.data - The data to use for the hashlink.\n   * @param {Array} options.resolvers - An array of Objects with key-value\n   *   pairs. Each object must contain a `scheme` key associated with a\n   *   Function({url, options}) that resolves any URL with the given scheme\n   *   and options to data.\n   *\n   * @returns {Promise<boolean>} true if the hashlink is valid, false otherwise.\n   */\n\n\n  async verify(_ref3) {\n    let {\n      data,\n      hashlink,\n      resolvers\n    } = _ref3;\n    const components = hashlink.split(':');\n\n    if (components.length > 3) {\n      throw new Error(`Hashlink \"${hashlink}\" is invalid; ` + 'it contains more than two colons.');\n    } // determine the base encoding decoder and decode the multihash value\n\n\n    const multibaseEncodedMultihash = stringToUint8Array(components[1]);\n\n    const multibaseDecoder = this._findDecoder(multibaseEncodedMultihash);\n\n    const encodedMultihash = multibaseDecoder.decode(multibaseEncodedMultihash); // determine the multihash decoder\n\n    const multihashDecoder = this._findDecoder(encodedMultihash); // extract the metadata to discover extra codecs\n\n\n    const codecs = [];\n\n    if (components.length === 3) {\n      const encodedMeta = stringToUint8Array(components[2]);\n      const cborMeta = multibaseDecoder.decode(encodedMeta);\n      const meta = cbor.decode(cborMeta); // extract transforms if they exist\n\n      if (meta.has(0x0c)) {\n        codecs.push(...meta.get(0x0c));\n      }\n    } // generate the complete list of codecs\n\n\n    codecs.push(multihashDecoder.algorithm, multibaseDecoder.algorithm); // generate the hashlink\n\n    const generatedHashlink = await this.encode({\n      data,\n      codecs\n    });\n    const generatedComponents = generatedHashlink.split(':'); // check to see if the encoded hashes match\n\n    return components[1] === generatedComponents[1];\n  }\n  /**\n   * Extends the Hashlink instance such that it can support new codecs\n   * such as new cryptographic hashing, base-encoding, and resolution\n   * mechanisms.\n   *\n   * @param {Codec} codec - A Codec instance that has a .encode()\n   *   and a .decode() method. It must also have an `identifier` and\n   *   `algorithm` property.\n   */\n\n\n  use(codec) {\n    this.registeredCodecs[codec.algorithm] = codec;\n  }\n  /**\n   * Finds a registered decoder for a given set of bytes or throws an Error.\n   *\n   * @param {Uint8Array} bytes - A stream of bytes to use when matching against\n   *   the registered decoders.\n   * @returns A registered decoder that can be used to encode/decode the byte\n   *   stream.\n   */\n\n\n  _findDecoder(bytes) {\n    const decoders = Object.values(this.registeredCodecs);\n    const decoder = decoders.find(decoder => decoder.identifier.every((id, i) => id === bytes[i]));\n\n    if (!decoder) {\n      throw new Error('Could not determine decoder for: ' + bytes);\n    }\n\n    return decoder;\n  }\n\n}","map":{"version":3,"names":["cbor","TextDecoder","stringToUint8Array","Hashlink","constructor","registeredCodecs","encode","data","urls","codecs","meta","undefined","Error","Array","isArray","forEach","url","outputData","reduce","output","codec","encoder","metadata","Map","set","experimental","transform","textDecoder","hashlink","decode","size","baseEncodingCodec","length","cborData","Uint8Array","mbCborData","verify","resolvers","components","split","multibaseEncodedMultihash","multibaseDecoder","_findDecoder","encodedMultihash","multihashDecoder","encodedMeta","cborMeta","has","push","get","algorithm","generatedHashlink","generatedComponents","use","bytes","decoders","Object","values","decoder","find","identifier","every","id","i"],"sources":["/Users/roberttineo/Documents/GitHub/molloy-textbook-exchange-front-end/node_modules/hashlink/Hashlink.js"],"sourcesContent":["/*!\n * Copyright (c) 2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nimport * as cbor from 'borc';\nimport {TextDecoder, stringToUint8Array} from './util.js';\n\nexport class Hashlink {\n  /**\n   * Encodes a new Hashlink instance that can be used to encode or decode\n   * data at URLs.\n   *\n   * @returns {Hashlink} A Hashlink used to encode and decode cryptographic\n   *   hyperlinks.\n   */\n  constructor() {\n    this.registeredCodecs = {};\n  }\n\n  /**\n   * Encodes a hashlink. If only a `url` parameter is provided, the URL is\n   * fetched, transformed, and encoded into a hashlink. If a data parameter\n   * is provided, the hashlink is encoded from the data.\n   *\n   * @param {Object} options - The options for the encode operation.\n   * @param {Uint8Array} [options.data] - The data associated with the given\n   *   URL. If provided, this data is used to encode the cryptographic hash.\n   * @param {Array} options.codecs - One or more codecs that should be used\n   *   to encode the data.\n   * @param {Array} [options.urls] - One or more URLs that contain the data\n   *   referred to by the hashlink.\n   * @param {Object} [options.meta] - A set of key-value metadata that will be\n   *   encoded into the hashlink.\n   *\n   * @returns {Promise<string>} Resolves to a string that is a hashlink.\n   */\n  async encode({data, urls, codecs, meta = {}}) {\n    // ensure data or urls are provided\n    if(data === undefined && urls === undefined) {\n      throw new Error('Either `data` or `urls` must be provided.');\n    }\n\n    // ensure codecs are provided\n    if(codecs === undefined) {\n      throw new Error('The hashlink creation `codecs` must be provided.');\n    }\n\n    if(urls !== undefined) {\n      // ensure urls are an array\n      if(!Array.isArray(urls)) {\n        urls = [urls];\n      }\n\n      // ensure all URLs are strings\n      urls.forEach(url => {\n        if(typeof url !== 'string') {\n          throw new Error(`URL \"${url}\" must be a string.`);\n        }\n      });\n\n      // merge meta options with urls\n      meta = {...meta, url: urls};\n    }\n\n    // generate the encoded cryptographic hash\n    const outputData = await codecs.reduce(async (output, codec) => {\n      const encoder = this.registeredCodecs[codec];\n      if(encoder === undefined) {\n        throw new Error(`Unknown cryptographic hash encoder \"${encoder}\".`);\n      }\n\n      return encoder.encode(await output);\n    }, data);\n\n    // generate the encoded metadata\n    const metadata = new Map();\n    if(meta.url) {\n      metadata.set(0x0f, meta.url);\n    }\n    if(meta['content-type']) {\n      metadata.set(0x0e, meta['content-type']);\n    }\n    if(meta.experimental) {\n      metadata.set(0x0d, meta.experimental);\n    }\n    if(meta.transform) {\n      metadata.set(0x0c, meta.transform);\n    }\n\n    // build the hashlink\n    const textDecoder = new TextDecoder();\n    let hashlink = 'hl:' + textDecoder.decode(outputData);\n\n    // append meta data if present\n    if(metadata.size > 0) {\n      const baseEncodingCodec = codecs[codecs.length - 1];\n      const cborData = new Uint8Array(cbor.encode(metadata));\n      const mbCborData = textDecoder.decode(\n        this.registeredCodecs[baseEncodingCodec].encode(cborData));\n      hashlink += ':' + mbCborData;\n    }\n\n    return hashlink;\n  }\n\n  /**\n   * Decodes a hashlink resulting in an object with key-value pairs\n   * representing the values encoded in the hashlink.\n   *\n   * @param {Object} options - The options for the encode operation.\n   * @param {string} options.hashlink - The encoded hashlink value to decode.\n   *\n   * @returns {Object} Returns an object with the decoded hashlink values.\n   */\n  decode({hashlink}) {\n    throw new Error('Not implemented.');\n  }\n\n  /**\n   * Verifies a hashlink resulting in a simple true or false value.\n   *\n   * @param {Object} options - The options for the encode operation.\n   * @param {string} options.hashlink - The encoded hashlink value to verify.\n   * @param {string} options.data - The data to use for the hashlink.\n   * @param {Array} options.resolvers - An array of Objects with key-value\n   *   pairs. Each object must contain a `scheme` key associated with a\n   *   Function({url, options}) that resolves any URL with the given scheme\n   *   and options to data.\n   *\n   * @returns {Promise<boolean>} true if the hashlink is valid, false otherwise.\n   */\n  async verify({data, hashlink, resolvers}) {\n    const components = hashlink.split(':');\n\n    if(components.length > 3) {\n      throw new Error(`Hashlink \"${hashlink}\" is invalid; ` +\n        'it contains more than two colons.');\n    }\n\n    // determine the base encoding decoder and decode the multihash value\n    const multibaseEncodedMultihash = stringToUint8Array(components[1]);\n    const multibaseDecoder = this._findDecoder(multibaseEncodedMultihash);\n    const encodedMultihash = multibaseDecoder.decode(multibaseEncodedMultihash);\n\n    // determine the multihash decoder\n    const multihashDecoder = this._findDecoder(encodedMultihash);\n\n    // extract the metadata to discover extra codecs\n    const codecs = [];\n    if(components.length === 3) {\n      const encodedMeta = stringToUint8Array(components[2]);\n      const cborMeta = multibaseDecoder.decode(encodedMeta);\n      const meta = cbor.decode(cborMeta);\n      // extract transforms if they exist\n      if(meta.has(0x0c)) {\n        codecs.push(...meta.get(0x0c));\n      }\n    }\n\n    // generate the complete list of codecs\n    codecs.push(multihashDecoder.algorithm, multibaseDecoder.algorithm);\n\n    // generate the hashlink\n    const generatedHashlink = await this.encode({data, codecs});\n    const generatedComponents = generatedHashlink.split(':');\n\n    // check to see if the encoded hashes match\n    return components[1] === generatedComponents[1];\n  }\n\n  /**\n   * Extends the Hashlink instance such that it can support new codecs\n   * such as new cryptographic hashing, base-encoding, and resolution\n   * mechanisms.\n   *\n   * @param {Codec} codec - A Codec instance that has a .encode()\n   *   and a .decode() method. It must also have an `identifier` and\n   *   `algorithm` property.\n   */\n  use(codec) {\n    this.registeredCodecs[codec.algorithm] = codec;\n  }\n\n  /**\n   * Finds a registered decoder for a given set of bytes or throws an Error.\n   *\n   * @param {Uint8Array} bytes - A stream of bytes to use when matching against\n   *   the registered decoders.\n   * @returns A registered decoder that can be used to encode/decode the byte\n   *   stream.\n   */\n  _findDecoder(bytes) {\n    const decoders = Object.values(this.registeredCodecs);\n    const decoder = decoders.find(\n      decoder => decoder.identifier.every((id, i) => id === bytes[i]));\n    if(!decoder) {\n      throw new Error('Could not determine decoder for: ' + bytes);\n    }\n    return decoder;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}